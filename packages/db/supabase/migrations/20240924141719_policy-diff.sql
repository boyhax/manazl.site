



drop policy "chats policy" on "public"."chats";

drop policy "Enable delete for users based on user_id" on "public"."messages";

drop policy "Enable update for users based on email" on "public"."messages";

drop policy "messages_insert_policy" on "public"."messages";

drop policy "messages_select_policy" on "public"."messages";

drop policy "states_select_policy" on "public"."states";

drop policy "Enable read access for all users" on "public"."likes";

drop policy "Enable read access for all users" on "public"."reservations";

drop policy "update by user or owner only" on "public"."reservations";

drop policy "user insert only" on "public"."reservations";


alter table "public"."metas" drop constraint "metas_pkey";

select 1; -- drop index if exists "public"."exclude_reservation_period";

drop index if exists "public"."metas_pkey";








create table "public"."listings_state" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "approved" boolean not null default true,
    "listings_id" bigint not null,
    "user_id" uuid
);


alter table "public"."listings_state" enable row level security;

alter table "public"."ads" add column "cat" text;

alter table "public"."chats" add column "listing_id" bigint;

alter table "public"."chats" add column "user_id" uuid default auth.uid();

alter table "public"."likes" add column "state_id" bigint;

alter table "public"."metas" drop column "value";

alter table "public"."metas" alter column "name" set data type text using "name"::text;

alter table "public"."reservations" add column "end_date" date not null;

alter table "public"."reservations" add column "start_date" date not null;

alter table "public"."variants" alter column "slots" set default '1'::smallint;





CREATE UNIQUE INDEX listings_state_pkey ON public.listings_state USING btree (id);

CREATE UNIQUE INDEX metas_pkey ON public.metas USING btree (id, name);




alter table "public"."listings_state" add constraint "listings_state_pkey" PRIMARY KEY using index "listings_state_pkey";

alter table "public"."metas" add constraint "metas_pkey" PRIMARY KEY using index "metas_pkey";


alter table "public"."chats" add constraint "chats_listing_id_fkey" FOREIGN KEY (listing_id) REFERENCES listings(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."chats" validate constraint "chats_listing_id_fkey";

alter table "public"."chats" add constraint "chats_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."chats" validate constraint "chats_user_id_fkey";

alter table "public"."likes" add constraint "likes_state_id_fkey" FOREIGN KEY (state_id) REFERENCES states(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."likes" validate constraint "likes_state_id_fkey";

alter table "public"."listings_state" add constraint "listings_state_listings_id_fkey" FOREIGN KEY (listings_id) REFERENCES listings(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."listings_state" validate constraint "listings_state_listings_id_fkey";

alter table "public"."listings_state" add constraint "listings_state_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE SET NULL not valid;

alter table "public"."listings_state" validate constraint "listings_state_user_id_fkey";

set check_function_bodies = off;

create or replace view "public"."users" as  SELECT users.id,
    users.email,
    (users.raw_user_meta_data ->> 'full_name'::text) AS full_name,
    (users.raw_user_meta_data ->> 'avatar_url'::text) AS avatar_url
   FROM auth.users;


CREATE OR REPLACE FUNCTION public.handle_new_listing()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$ begin
insert into
    public.states (id,listing_id)
values
    (new.id,new.id);
return new;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.set_reservation_period()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  -- Check if both startDate and endDate are not null
  IF NEW."start_date" IS NOT NULL AND NEW."end_date" IS NOT NULL THEN
    -- Set the reservation_period as a tstzrange (timestamp with time zone range)
    NEW.reservation_period := tstzrange(
      NEW."start_date"::timestamptz, 
      NEW."end_date"::timestamptz, 
      '[]'
    );
  END IF;
  
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_geo_location()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$BEGIN NEW.geo_location := ST_Point(NEW.place_point [2], NEW.place_point [1]) :: geography;

RETURN NEW;

END;$function$
;

CREATE OR REPLACE FUNCTION public.update_likes_count()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$ BEGIN IF (TG_OP = 'INSERT') THEN
UPDATE
    states
SET
    likes = likes + 1
WHERE
    listing_id = NEW.listing_id;

ELSIF (TG_OP = 'DELETE') THEN
UPDATE
    states
SET
    likes = likes - 1
WHERE
    listing_id = OLD.listing_id;
END IF;
RETURN NULL;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$ BEGIN NEW.updated_at = NOW();

RETURN NEW;

END;

$function$
;


grant delete on table "public"."listings_reports" to "postgres";

grant insert on table "public"."listings_reports" to "postgres";

grant references on table "public"."listings_reports" to "postgres";

grant select on table "public"."listings_reports" to "postgres";

grant trigger on table "public"."listings_reports" to "postgres";

grant truncate on table "public"."listings_reports" to "postgres";

grant update on table "public"."listings_reports" to "postgres";

grant delete on table "public"."listings_state" to "anon";

grant insert on table "public"."listings_state" to "anon";

grant references on table "public"."listings_state" to "anon";

grant select on table "public"."listings_state" to "anon";

grant trigger on table "public"."listings_state" to "anon";

grant truncate on table "public"."listings_state" to "anon";

grant update on table "public"."listings_state" to "anon";

grant delete on table "public"."listings_state" to "authenticated";

grant insert on table "public"."listings_state" to "authenticated";

grant references on table "public"."listings_state" to "authenticated";

grant select on table "public"."listings_state" to "authenticated";

grant trigger on table "public"."listings_state" to "authenticated";

grant truncate on table "public"."listings_state" to "authenticated";

grant update on table "public"."listings_state" to "authenticated";

grant delete on table "public"."listings_state" to "postgres";

grant insert on table "public"."listings_state" to "postgres";

grant references on table "public"."listings_state" to "postgres";

grant select on table "public"."listings_state" to "postgres";

grant trigger on table "public"."listings_state" to "postgres";

grant truncate on table "public"."listings_state" to "postgres";

grant update on table "public"."listings_state" to "postgres";

grant delete on table "public"."listings_state" to "service_role";

grant insert on table "public"."listings_state" to "service_role";

grant references on table "public"."listings_state" to "service_role";

grant select on table "public"."listings_state" to "service_role";

grant trigger on table "public"."listings_state" to "service_role";

grant truncate on table "public"."listings_state" to "service_role";

grant update on table "public"."listings_state" to "service_role";

grant delete on table "public"."post_reports" to "postgres";

grant insert on table "public"."post_reports" to "postgres";

grant references on table "public"."post_reports" to "postgres";

grant select on table "public"."post_reports" to "postgres";

grant trigger on table "public"."post_reports" to "postgres";

grant truncate on table "public"."post_reports" to "postgres";

grant update on table "public"."post_reports" to "postgres";

grant delete on table "public"."posts_ratings" to "postgres";

grant insert on table "public"."posts_ratings" to "postgres";

grant references on table "public"."posts_ratings" to "postgres";

grant select on table "public"."posts_ratings" to "postgres";

grant trigger on table "public"."posts_ratings" to "postgres";

grant truncate on table "public"."posts_ratings" to "postgres";

grant update on table "public"."posts_ratings" to "postgres";





create policy "chats_id"
on "public"."chats"
as permissive
for all
to authenticated
using (((user_id = ( SELECT auth.uid() AS uid)) OR (( SELECT auth.uid() AS uid) = ( SELECT listings.user_id
   FROM listings
  WHERE (listings.id = chats.listing_id)))))
with check (((user_id = ( SELECT auth.uid() AS uid)) OR (( SELECT auth.uid() AS uid) = ( SELECT listings.user_id
   FROM listings
  WHERE (listings.id = chats.listing_id)))));








create policy "chats_messages"
on "public"."messages"
as permissive
for all
to authenticated
using (((auth.uid() = user_id) OR (auth.uid() = ( SELECT listings.user_id
   FROM listings
  WHERE (listings.id = ( SELECT chats.listing_id
           FROM chats
          WHERE (chats.id = messages.chat_id)))))))
with check (((auth.uid() = user_id) OR (auth.uid() = ( SELECT listings.user_id
   FROM listings
  WHERE (listings.id = ( SELECT chats.listing_id
           FROM chats
          WHERE (chats.id = messages.chat_id)))))));


create policy "Enable read access for all users"
on "public"."states"
as permissive
for select
to anon, authenticated
using (true);


create policy "Enable read access for all users"
on "public"."likes"
as permissive
for select
to authenticated, anon
using ((( SELECT auth.uid() AS uid) = user_id));


create policy "Enable read access for all users"
on "public"."reservations"
as permissive
for select
to authenticated
using (((( SELECT auth.uid() AS uid) = user_id) OR (( SELECT auth.uid() AS uid) = ( SELECT listings.user_id
   FROM listings
  WHERE (listings.id = reservations.listing_id)))));


create policy "update by user or owner only"
on "public"."reservations"
as permissive
for update
to authenticated
using (((( SELECT auth.uid() AS uid) = user_id) OR (( SELECT auth.uid() AS uid) = ( SELECT listings.user_id
   FROM listings
  WHERE (listings.id = reservations.listing_id)))));


create policy "user insert only"
on "public"."reservations"
as permissive
for insert
to authenticated
with check (((( SELECT auth.uid() AS uid) = user_id) OR (( SELECT auth.uid() AS uid) = ( SELECT listings.user_id
   FROM listings
  WHERE (listings.id = reservations.listing_id)))));



