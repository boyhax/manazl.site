-- Drop the existing enum type if it exists
DROP TYPE IF EXISTS public.app_permission;

-- Recreate the enum type with all values in a single step
CREATE TYPE public.app_permission AS ENUM (
    'channels.delete',
    'messages.delete',
    'messages.select',
    'messages.insert',
    'listings.delete',
    'listings.select',
    'listings.insert',
    'listings.update',
    'variants.delete',
    'variants.select',
    'variants.insert',
    'variants.update',
    'room_availabilty.delete',
    'room_availabilty.select',
    'room_availabilty.insert',
    'room_availabilty.update',
    'role_permissions.delete',
    'role_permissions.select',
    'role_permissions.insert',
    'role_permissions.update',
    'user_roles.delete',
    'user_roles.select',
    'user_roles.insert',
    'user_roles.update'
);
-- Application roles
create type public.app_role as enum ('admin', 'moderator');

-- USER ROLES
create table public.user_roles (
    id bigint generated by default as identity primary key,
    user_id uuid references auth.users on delete cascade not null,
    role app_role not null,
    unique (user_id, role)
);

comment on table public.user_roles is 'Application roles for each user.';

-- ROLE PERMISSIONS
create table public.role_permissions (
    id bigint generated by default as identity primary key,
    role app_role not null,
    permission app_permission not null,
    unique (role, permission)
);

comment on table public.role_permissions is 'Application permissions for each role.';

insert into
    public.role_permissions (role, permission)
values
    ('admin', 'channels.delete'),
    ('admin', 'messages.delete'),
    ('admin', 'messages.insert'),
    ('admin', 'listings.delete'),
    ('admin', 'listings.select'),
    ('admin', 'listings.insert'),
    ('admin', 'listings.update'),
    ('moderator', 'channels.delete'),
    ('moderator', 'messages.delete'),
    ('moderator', 'messages.insert'),
('admin', 'variants.delete'),
('admin', 'variants.select'),
('admin', 'variants.insert'),
('admin', 'variants.update'),
('moderator', 'variants.delete'),
('moderator', 'variants.select'),
('moderator', 'variants.insert'),
('moderator', 'variants.update'),
('admin', 'room_availabilty.delete'),
('admin', 'room_availabilty.select'),
('admin', 'room_availabilty.insert'),
('admin', 'room_availabilty.update'),
('moderator', 'room_availabilty.delete'),
('moderator', 'room_availabilty.select'),
('moderator', 'room_availabilty.insert'),
('moderator', 'room_availabilty.update'),
('admin', 'role_permissions.delete'),
('admin', 'role_permissions.select'),
('admin', 'role_permissions.insert'),
('admin', 'role_permissions.update'),
('admin', 'user_roles.delete'),
('admin', 'user_roles.select'),
('admin', 'user_roles.insert'),
('admin', 'user_roles.update');

-- Create the auth hook function
create
or replace function public.custom_access_token_hook(event jsonb) returns jsonb language plpgsql stable as $$ declare claims jsonb;

user_role public.app_role;

begin -- Fetch the user role in the user_roles table
select
    role into user_role
from
    public.user_roles
where
    user_id = (event ->> 'user_id') :: uuid;

claims := event -> 'claims';

if user_role is not null then -- Set the claim
claims := jsonb_set(claims, '{user_role}', to_jsonb(user_role));

else claims := jsonb_set(claims, '{user_role}', 'null');

end if;

-- Update the 'claims' object in the original event
event := jsonb_set(event, '{claims}', claims);

-- Return the modified or original event
return event;

end;

$$;

grant usage on schema public to supabase_auth_admin;

grant execute on function public.custom_access_token_hook to supabase_auth_admin;

revoke execute on function public.custom_access_token_hook
from
    authenticated,
    anon,
    public;

-- Grant and revoke permissions
GRANT ALL ON TABLE public.user_roles TO supabase_auth_admin;

REVOKE ALL ON TABLE public.user_roles
FROM
    authenticated,
    anon,
    public;

-- Create policy
CREATE POLICY "Allow auth admin to read user roles" ON public.user_roles AS permissive FOR
SELECT
    TO supabase_auth_admin USING (true);

-- Create or replace the authorize function
CREATE
OR REPLACE FUNCTION public.authorize(requested_permission app_permission) RETURNS boolean AS 
$$ DECLARE bind_permissions INT;

user_role public.app_role;

BEGIN -- Fetch user role once and store it to reduce number of calls
SELECT
    (auth.jwt() ->> 'user_role') :: public.app_role INTO user_role;

-- Count the permissions
SELECT
    COUNT(*) INTO bind_permissions
FROM
    public.role_permissions
WHERE
    role_permissions.permission = requested_permission
    AND role_permissions.role = user_role;

-- Return true if permissions are greater than 0
RETURN bind_permissions > 0;

END;

$$ LANGUAGE plpgsql STABLE SECURITY DEFINER;
set search_path = '';